[{"path":"/home/u119070/git/elastic-sycl-hls/include_sycl/exception_handler.hpp", "name":"exception_handler.hpp", "has_active_debug_locs":false, "absName":"/home/u119070/git/elastic-sycl-hls/include_sycl/exception_handler.hpp", "content":"#ifndef __EXCEPTIONHANDLER_HPP__\u000A#define __EXCEPTIONHANDLER_HPP__\u000A#include <sycl/sycl.hpp>\u000A#include <exception>\u000A#include <iostream>\u000A\u000Avoid exception_handler(sycl::exception_list exceptions) {\u000A  for (std::exception_ptr const &e : exceptions) {\u000A    try {\u000A      std::rethrow_exception(e);\u000A    } catch (sycl::exception const &e) {\u000A      std::cout << \"Caught asynchronous SYCL exception:\\n\"\u000A                << e.what() << std::endl;\u000A    }\u000A  }\u000A}\u000A\u000A\u000A#endif //__EXCEPTIONHANDLER_HPP__\u000A"}, {"path":"/home/u119070/git/elastic-sycl-hls/experiments/get_tanh_dram.cpp", "name":"get_tanh_dram.cpp", "has_active_debug_locs":false, "absName":"/home/u119070/git/elastic-sycl-hls/experiments/get_tanh_dram.cpp", "content":"#include <sycl/sycl.hpp>\u000A#include <algorithm>\u000A#include <iostream>\u000A#include <numeric>\u000A#include <stdlib.h>\u000A#include <vector>\u000A#include <random>\u000A\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A#include \"memory_utils.hpp\"\u000A#include \"exception_handler.hpp\"\u000A\u000Ausing namespace sycl;\u000Ausing namespace fpga_tools;\u000A\u000A// Forward declare kernel name.\u000Aclass MainKernel;\u000A\u000A\u000Adouble get_tanh_kernel(queue &q, std::vector<int> &h_A, const std::vector<int> h_addr_in,\u000A                       const std::vector<int> h_addr_out) {\u000A  const uint array_size = h_A.size();\u000A\u000A  int* A = fpga_tools::toDevice(h_A, q);\u000A  int* addr_in = fpga_tools::toDevice(h_addr_in, q);\u000A  int* addr_out = fpga_tools::toDevice(h_addr_out, q);\u000A\u000A  auto event = q.single_task<MainKernel>([=]() [[intel::kernel_args_restrict]] {\u000A    // [[intel::fpga_register]]\u000A    int atanh[12] = {0x08C9, 0x0416, 0x0202, 0x0100, 0x0080, 0x0064,\u000A                     0x0032, 0x0010, 0x0008, 0x0004, 0x0002, 0x0001};\u000A    // [[intel::fpga_register]]\u000A    int cosh[5] = {0x1000, 0x18B0, 0x3C31, 0xA115, 0x1B4EE};\u000A    // [[intel::fpga_register]]\u000A    int sinh[5] = {0x0, 0x12CD, 0x3A07, 0xA049, 0x1B4A3};\u000A\u000A    for (int i = 0; i < array_size; i++) {\u000A      // Input angle\u000A      int beta = A[addr_in[i]];\u000A      // Result of tanh, sinh and cosh\u000A      int result = 4096; // Saturation effect\u000A\u000A      // Implement approximate range of the hyperbolic CORDIC block\u000A      if (beta < 20480) {\u000A        int x = 0x1351;\u000A        int y = 0;\u000A        int x_new;\u000A        int index_trigo;\u000A        int result_cosh, result_sinh;\u000A        int outputcosh, outputsinh;\u000A\u000A        if (beta >= 8192) {\u000A          index_trigo = 4;\u000A        } else if (beta >= 12288) {\u000A          index_trigo = 3;\u000A        } else if (beta >= 8192) {\u000A          index_trigo = 2;\u000A        } else if (beta >= 4096) {\u000A          index_trigo = 1;\u000A        } else {\u000A          index_trigo = 0;\u000A        }\u000A        beta = beta - index_trigo * 4096;\u000A\u000A        // Call to the hyperbolic CORDIC block\u000A        #pragma unroll\u000A        for (int k = 1; k <= 12; k++) {\u000A          // force the 3k+1 th iteration to be repeated\u000A          if (((k % 3) == 1) && (k != 1)) {\u000A            #pragma unroll\u000A            for (int j = 1; j <= 2; j++) {\u000A              // beta<0 anti-clockwise rotation\u000A              if (beta < 0) {\u000A                x_new = x - (y >> k);\u000A                y -= x >> k;\u000A                beta += atanh[k - 1];\u000A              }\u000A              // beta>0 clockwise rotation\u000A              else {\u000A                x_new = x + (y >> k);\u000A                y += (x >> k);\u000A                beta -= atanh[k - 1];\u000A              }\u000A              x = x_new;\u000A            }\u000A          } else {\u000A            if (beta < 0) {\u000A              x_new = x - (y >> k);\u000A              y -= x >> k;\u000A              beta += atanh[k - 1];\u000A            }\u000A            // beta>0 clockwise rotation\u000A            else {\u000A              x_new = x + (y >> k);\u000A              y += (x >> k);\u000A              beta -= atanh[k - 1];\u000A            }\u000A            x = x_new;\u000A          }\u000A        }\u000A        outputcosh = x;\u000A        outputsinh = y;\u000A\u000A        // Trigonometric rules application\u000A        result_cosh =\u000A            (sinh[index_trigo] * outputcosh + cosh[index_trigo] * outputsinh);\u000A        result_sinh =\u000A            (cosh[index_trigo] * outputcosh + sinh[index_trigo] * outputsinh) >>\u000A            12;\u000A        result = result_cosh / result_sinh;\u000A      }\u000A\u000A      // Central symmetry correction\u000A      A[addr_out[i]] = result;\u000A    }\u000A  });\u000A\u000A  event.wait();\u000A  q.copy(A, h_A.data(), h_A.size()).wait();\u000A\u000A  sycl::free(A, q);\u000A  sycl::free(addr_in, q);\u000A  sycl::free(addr_out, q);\u000A\u000A  auto start = event.get_profiling_info<info::event_profiling::command_start>();\u000A  auto end = event.get_profiling_info<info::event_profiling::command_end>();\u000A  double time_in_ms = static_cast<double>(end - start) / 1000000;\u000A\u000A  return time_in_ms;\u000A}\u000A\u000A\u000A\u000Avoid init_data(std::vector<int> &A, std::vector<int> &addr_in, std::vector<int> &addr_out,\u000A                const uint percentage) {\u000A  std::default_random_engine generator;\u000A  std::uniform_int_distribution<int> distribution(0, 99);\u000A  auto dice = std::bind(distribution, generator);\u000A\u000A  for (int i = 0; i < A.size(); i++) {\u000A    A[i] = (i % 2 == 0) ? rand()%1000 : 30000;\u000A    \u000A    addr_in[i] = (dice() < percentage) ? std::max(i - 1, 0) : i;\u000A    addr_out[i] = addr_in[i];\u000A  }\u000A}\u000A\u000A\u000Avoid get_tanh_cpu(std::vector<int> &A, const std::vector<int> addr_in,\u000A                  const std::vector<int> addr_out) {\u000A  int atanh[12] = {0x08C9, 0x0416, 0x0202, 0x0100, 0x0080, 0x0064,\u000A                   0x0032, 0x0010, 0x0008, 0x0004, 0x0002, 0x0001};\u000A  int cosh[5] = {0x1000, 0x18B0, 0x3C31, 0xA115, 0x1B4EE};\u000A  int sinh[5] = {0x0, 0x12CD, 0x3A07, 0xA049, 0x1B4A3};\u000A\u000A  for (int i = 0; i < A.size(); i++) {\u000A    // Input angle\u000A    int beta = A[addr_in[i]];\u000A    // Result of tanh, sinh and cosh\u000A    int result = 4096; // Saturation effect\u000A\u000A    // Implement approximate range of the hyperbolic CORDIC block\u000A    if (beta < 20480) {\u000A      int x = 0x1351;\u000A      int y = 0;\u000A      int x_new;\u000A      int index_trigo;\u000A      int result_cosh, result_sinh;\u000A      int outputcosh, outputsinh;\u000A\u000A      if (beta >= 8192) {\u000A        index_trigo = 4;\u000A      } else if (beta >= 12288) {\u000A        index_trigo = 3;\u000A      } else if (beta >= 8192) {\u000A        index_trigo = 2;\u000A      } else if (beta >= 4096) {\u000A        index_trigo = 1;\u000A      } else {\u000A        index_trigo = 0;\u000A      }\u000A      beta = beta - index_trigo * 4096;\u000A\u000A      // Call to the hyperbolic CORDIC block\u000A      for (int k = 1; k <= 12; k++) {\u000A        // force the 3k+1 th iteration to be repeated\u000A        if (((k % 3) == 1) && (k != 1)) {\u000A          for (int j = 1; j <= 2; j++) {\u000A            // beta<0 anti-clockwise rotation\u000A            if (beta < 0) {\u000A              x_new = x - (y >> k);\u000A              y -= x >> k;\u000A              beta += atanh[k - 1];\u000A            }\u000A            // beta>0 clockwise rotation\u000A            else {\u000A              x_new = x + (y >> k);\u000A              y += (x >> k);\u000A              beta -= atanh[k - 1];\u000A            }\u000A            x = x_new;\u000A          }\u000A        } else {\u000A          if (beta < 0) {\u000A            x_new = x - (y >> k);\u000A            y -= x >> k;\u000A            beta += atanh[k - 1];\u000A          }\u000A          // beta>0 clockwise rotation\u000A          else {\u000A            x_new = x + (y >> k);\u000A            y += (x >> k);\u000A            beta -= atanh[k - 1];\u000A          }\u000A          x = x_new;\u000A        }\u000A      }\u000A      outputcosh = x;\u000A      outputsinh = y;\u000A\u000A      // Trigonometric rules application\u000A      result_cosh = (sinh[index_trigo] * outputcosh + cosh[index_trigo] * outputsinh);\u000A      result_sinh = (cosh[index_trigo] * outputcosh + sinh[index_trigo] * outputsinh) >> 12;\u000A      result = result_cosh / result_sinh;\u000A    }\u000A\u000A    // Central symmetry correction\u000A    A[addr_out[i]] = result;\u000A  }\u000A}\u000A\u000A\u000A\u000Aint main(int argc, char *argv[]) {\u000A  int ARRAY_SIZE = 1000;\u000A  int PERCENTAGE = 0;\u000A  try {\u000A    if (argc > 1) {\u000A      ARRAY_SIZE = int(atoi(argv[1]));\u000A    }\u000A    if (argc > 2) {\u000A      PERCENTAGE = int(atoi(argv[2]));\u000A      \u000A      if (PERCENTAGE < 0 || PERCENTAGE > 100)\u000A        throw std::invalid_argument(\"Invalid percentage.\");\u000A    }\u000A  } catch (exception const &e) {\u000A    std::cout << \"Incorrect argv.\\nUsage:\\n\"\u000A              << \"  ./executable [ARRAY_SIZE] [PERCENTAGE (% of iterations \"\u000A                 \"with dependencies.)]\\n\";\u000A    std::terminate();\u000A  }\u000A\u000A#if FPGA_SIM\u000A  auto d_selector = sycl::ext::intel::fpga_simulator_selector_v;\u000A#elif FPGA_HW \u000A  auto d_selector = sycl::ext::intel::fpga_selector_v;\u000A#else  // #if FPGA_EMULATOR\u000A  auto d_selector = sycl::ext::intel::fpga_emulator_selector_v;\u000A#endif\u000A  try {\u000A    // Enable profiling.\u000A    property_list properties{property::queue::enable_profiling()};\u000A    queue q(d_selector, exception_handler, properties);\u000A\u000A    // Print out the device information used for the kernel code.\u000A    std::cout << \"Running on device: \" << q.get_device().get_info<info::device::name>() << \"\\n\";\u000A\u000A    std::vector<int> A(ARRAY_SIZE);\u000A    std::vector<int> addr_in(ARRAY_SIZE);\u000A    std::vector<int> addr_out(ARRAY_SIZE);\u000A\u000A    init_data(A, addr_in, addr_out,  PERCENTAGE);\u000A\u000A    std::vector<int> A_cpu(ARRAY_SIZE);\u000A    std::copy(A.begin(), A.end(), A_cpu.begin());\u000A\u000A    auto kernel_time = get_tanh_kernel(q, A, addr_in, addr_out);\u000A\u000A    std::cout << \"\\nKernel time (ms): \" << kernel_time << \"\\n\";\u000A\u000A    get_tanh_cpu(A_cpu, addr_in, addr_out);\u000A    if (std::equal(A.begin(), A.end(), A_cpu.begin())) {\u000A      std::cout << \"Passed\\n\";\u000A    } else {\u000A      std::cout << \"Failed\";\u000A      std::cout << \" sum(A_fpga) = \" << std::accumulate(A.begin(), A.end(), 0) << \"\\n\";\u000A      std::cout << \" sum(A_cpu) = \" << std::accumulate(A_cpu.begin(), A_cpu.end(), 0) << \"\\n\";\u000A    }\u000A  } catch (exception const &e) {\u000A    std::cout << \"An exception was caught.\\n\";\u000A    std::terminate();\u000A  }\u000A\u000A  return 0;\u000A}\u000A\u000A"}, {"path":"/home/u119070/git/elastic-sycl-hls/include_sycl/memory_utils.hpp", "name":"memory_utils.hpp", "has_active_debug_locs":false, "absName":"/home/u119070/git/elastic-sycl-hls/include_sycl/memory_utils.hpp", "content":"#ifndef __MEMORY_UTILS_HPP__\u000A#define __MEMORY_UTILS_HPP__\u000A\u000A#include <type_traits>\u000A\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A#include <sycl/sycl.hpp>\u000A\u000A#include \"metaprogramming_utils.hpp\"\u000A\u000A//\u000A// The utilities in this file are used for converting streaming data to/from\u000A// memory from/to a pipe.\u000A//\u000A\u000Anamespace fpga_tools {\u000A\u000Anamespace detail {\u000A\u000A//\u000A// Helper to check if a SYCL pipe and pointer have the same base type\u000A//\u000Atemplate <typename PipeT, typename PtrT>\u000Astruct pipe_and_pointer_have_same_base {\u000A  using PipeBaseT =\u000A      std::conditional_t<fpga_tools::has_subscript_v<PipeT>,\u000A                         std::decay_t<decltype(std::declval<PipeT>()[0])>,\u000A                         PipeT>;\u000A  using PtrBaseT = std::decay_t<decltype(std::declval<PtrT>()[0])>;\u000A  static constexpr bool value = std::is_same_v<PipeBaseT, PtrBaseT>;\u000A};\u000A\u000Atemplate <typename PipeT, typename PtrT>\u000Ainline constexpr bool pipe_and_pointer_have_same_base_v =\u000A    pipe_and_pointer_have_same_base<PipeT, PtrT>::value;\u000A\u000A//\u000A// Streams data from 'in_ptr' into 'Pipe', 'elements_per_cycle' elements at a\u000A// time\u000A//\u000Atemplate <typename Pipe, int elements_per_cycle, typename PtrT>\u000Avoid MemoryToPipeRemainder(PtrT in_ptr, size_t full_count,\u000A                           size_t remainder_count) {\u000A  static_assert(fpga_tools::is_sycl_pipe_v<Pipe>);\u000A  using PipeT = decltype(Pipe::read());\u000A  static_assert(fpga_tools::has_subscript_v<PipeT>);\u000A  static_assert(fpga_tools::has_subscript_v<PtrT>);\u000A  static_assert(PipeT::size == elements_per_cycle);\u000A  static_assert(pipe_and_pointer_have_same_base_v<PipeT, PtrT>);\u000A\u000A  for (size_t i = 0; i < full_count; i++) {\u000A    PipeT pipe_data;\u000A#pragma unroll\u000A    for (int j = 0; j < elements_per_cycle; j++) {\u000A      pipe_data[j] = in_ptr[i * elements_per_cycle + j];\u000A    }\u000A    Pipe::write(pipe_data);\u000A  }\u000A\u000A  PipeT pipe_data;\u000A  for (size_t i = 0; i < remainder_count; i++) {\u000A    pipe_data[i] = in_ptr[full_count * elements_per_cycle + i];\u000A  }\u000A  Pipe::write(pipe_data);\u000A}\u000A\u000A//\u000A// Streams data from 'in_ptr' into 'Pipe', 'elements_per_cycle' elements at a\u000A// time with the guarantee that 'elements_per_cycle' is a multiple of 'count'\u000A//\u000Atemplate <typename Pipe, int elements_per_cycle, typename PtrT>\u000Avoid MemoryToPipeNoRemainder(PtrT in_ptr, size_t count) {\u000A  static_assert(fpga_tools::is_sycl_pipe_v<Pipe>);\u000A  using PipeT = decltype(Pipe::read());\u000A  static_assert(fpga_tools::has_subscript_v<PipeT>);\u000A  static_assert(fpga_tools::has_subscript_v<PtrT>);\u000A  static_assert(PipeT::size == elements_per_cycle);\u000A  static_assert(pipe_and_pointer_have_same_base_v<PipeT, PtrT>);\u000A\u000A  for (size_t i = 0; i < count; i++) {\u000A    PipeT pipe_data;\u000A#pragma unroll\u000A    for (int j = 0; j < elements_per_cycle; j++) {\u000A      pipe_data[j] = in_ptr[i * elements_per_cycle + j];\u000A    }\u000A    Pipe::write(pipe_data);\u000A  }\u000A}\u000A\u000A//\u000A// Streams data from 'Pipe' to 'out_ptr', 'elements_per_cycle' elements at a\u000A// time\u000A//\u000Atemplate <typename Pipe, int elements_per_cycle, typename PtrT>\u000Avoid PipeToMemoryRemainder(PtrT out_ptr, size_t full_count,\u000A                           size_t remainder_count) {\u000A  static_assert(fpga_tools::is_sycl_pipe_v<Pipe>);\u000A  using PipeT = decltype(Pipe::read());\u000A  static_assert(fpga_tools::has_subscript_v<PipeT>);\u000A  static_assert(fpga_tools::has_subscript_v<PtrT>);\u000A  static_assert(PipeT::size == elements_per_cycle);\u000A  static_assert(pipe_and_pointer_have_same_base_v<PipeT, PtrT>);\u000A\u000A  for (size_t i = 0; i < full_count; i++) {\u000A    auto pipe_data = Pipe::read();\u000A#pragma unroll\u000A    for (int j = 0; j < elements_per_cycle; j++) {\u000A      out_ptr[i * elements_per_cycle + j] = pipe_data[j];\u000A    }\u000A  }\u000A\u000A  auto pipe_data = Pipe::read();\u000A  for (size_t i = 0; i < remainder_count; i++) {\u000A    out_ptr[full_count * elements_per_cycle + i] = pipe_data[i];\u000A  }\u000A}\u000A\u000A//\u000A// Streams data from 'Pipe' to 'out_ptr', 'elements_per_cycle' elements at a\u000A// time with the guarantee that 'elements_per_cycle' is a multiple of 'count'\u000A//\u000Atemplate <typename Pipe, int elements_per_cycle, typename PtrT>\u000Avoid PipeToMemoryNoRemainder(PtrT out_ptr, size_t count) {\u000A  static_assert(fpga_tools::is_sycl_pipe_v<Pipe>);\u000A  using PipeT = decltype(Pipe::read());\u000A  static_assert(fpga_tools::has_subscript_v<PipeT>);\u000A  static_assert(fpga_tools::has_subscript_v<PtrT>);\u000A  static_assert(PipeT::size == elements_per_cycle);\u000A  static_assert(pipe_and_pointer_have_same_base_v<PipeT, PtrT>);\u000A\u000A  for (size_t i = 0; i < count; i++) {\u000A    auto pipe_data = Pipe::read();\u000A#pragma unroll\u000A    for (int j = 0; j < elements_per_cycle; j++) {\u000A      out_ptr[i * elements_per_cycle + j] = pipe_data[j];\u000A    }\u000A  }\u000A}\u000A\u000A}  // namespace detail\u000A\u000A//\u000A// Streams data from memory to a SYCL pipe 1 element a time\u000A//\u000Atemplate <typename Pipe, typename PtrT>\u000Avoid MemoryToPipe(PtrT in_ptr, size_t count) {\u000A  static_assert(fpga_tools::is_sycl_pipe_v<Pipe>);\u000A  using PipeT = decltype(Pipe::read());\u000A  static_assert(fpga_tools::has_subscript_v<PtrT>);\u000A  static_assert(detail::pipe_and_pointer_have_same_base_v<PipeT, PtrT>);\u000A\u000A  for (size_t i = 0; i < count; i++) {\u000A    Pipe::write(in_ptr[i]);\u000A  }\u000A}\u000A\u000A//\u000A// Streams data from memory to a SYCL pipe 'elements_per_cycle' elements a time\u000A//\u000Atemplate <typename Pipe, int elements_per_cycle, bool remainder, typename PtrT>\u000Avoid MemoryToPipe(PtrT in_ptr, size_t count) {\u000A  if constexpr (!remainder) {\u000A    // user promises there is not remainder\u000A    detail::MemoryToPipeNoRemainder<Pipe, elements_per_cycle>(in_ptr, count);\u000A  } else {\u000A    // might have a remainder and it was not specified, so calculate it\u000A    auto full_count = (count / elements_per_cycle) * elements_per_cycle;\u000A    auto remainder_count = count % elements_per_cycle;\u000A    detail::MemoryToPipeRemainder<Pipe, elements_per_cycle>(in_ptr, full_count,\u000A                                                            remainder_count);\u000A  }\u000A}\u000A\u000A//\u000A// Streams data from memory to a SYCL pipe 'elements_per_cycle' elements a time\u000A// In this version, the user has specified a the amount of remainder\u000A//\u000Atemplate <typename Pipe, int elements_per_cycle, bool remainder, typename PtrT>\u000Avoid MemoryToPipe(PtrT in_ptr, size_t full_count, size_t remainder_count) {\u000A  if constexpr (!remainder) {\u000A    // user promises there is not remainder\u000A    detail::MemoryToPipeNoRemainder<Pipe, elements_per_cycle>(in_ptr,\u000A                                                              full_count);\u000A  } else {\u000A    // might have a remainder that was specified by the user\u000A    detail::MemoryToPipeRemainder<Pipe, elements_per_cycle>(in_ptr, full_count,\u000A                                                            remainder_count);\u000A  }\u000A}\u000A\u000A//\u000A// Streams data from a SYCL pipe to memory 1 element a time\u000A//\u000Atemplate <typename Pipe, typename PtrT>\u000Avoid PipeToMemory(PtrT out_ptr, size_t count) {\u000A  using PipeT = decltype(Pipe::read());\u000A  static_assert(fpga_tools::has_subscript_v<PtrT>);\u000A  static_assert(detail::pipe_and_pointer_have_same_base_v<PipeT, PtrT>);\u000A\u000A  for (size_t i = 0; i < count; i++) {\u000A    out_ptr[i] = Pipe::read();\u000A  }\u000A}\u000A\u000A//\u000A// Streams data from a SYCL pipe to memory 'elements_per_cycle' elements a time\u000A//\u000Atemplate <typename Pipe, int elements_per_cycle, bool remainder, typename PtrT>\u000Avoid PipeToMemory(PtrT out_ptr, size_t count) {\u000A  if constexpr (!remainder) {\u000A    detail::PipeToMemoryNoRemainder<Pipe, elements_per_cycle>(out_ptr, count);\u000A  } else {\u000A    auto full_count = (count / elements_per_cycle) * elements_per_cycle;\u000A    auto remainder_count = count % elements_per_cycle;\u000A    detail::PipeToMemoryRemainder<Pipe, elements_per_cycle>(out_ptr, full_count,\u000A                                                            remainder_count);\u000A  }\u000A}\u000A\u000A//\u000A// Streams data from a SYCL pipe to memory 'elements_per_cycle' elements a time\u000A// In this version, the user has specified a the amount of remainder\u000A//\u000Atemplate <typename Pipe, int elements_per_cycle, bool remainder, typename PtrT>\u000Avoid PipeToMemory(PtrT out_ptr, size_t full_count, size_t remainder_count) {\u000A  if constexpr (!remainder) {\u000A    detail::PipeToMemoryNoRemainder<Pipe, elements_per_cycle>(out_ptr,\u000A                                                              full_count);\u000A  } else {\u000A    detail::PipeToMemoryRemainder<Pipe, elements_per_cycle>(out_ptr, full_count,\u000A                                                            remainder_count);\u000A  }\u000A}\u000A\u000A\u000A/// 1. Allocate device_memory (same num bytes as in host_vector)\u000A/// 2. Transfer data host_vector->device_memory\u000A/// 3. Return sycl::device_ptr to device_memory\u000Atemplate<typename T>\u000AT* toDevice(const std::vector<T> &host_vector, sycl::queue &q) {\u000A  T* device_data = sycl::malloc_device<T>(host_vector.size(), q);\u000A  q.copy(host_vector.data(), device_data, host_vector.size()).wait();\u000A  return device_data;\u000A}\u000Atemplate<typename T, int N>\u000AT* toDevice(const T* host_array[N], sycl::queue &q) {\u000A  T* device_data = sycl::malloc_device<T>(N, q);\u000A  q.copy(host_array, device_data, N).wait();\u000A  return device_data;\u000A}\u000Atemplate<typename T>\u000AT* toDevice(const T* host_array, const int N, sycl::queue &q) {\u000A  T* device_data = sycl::malloc_device<T>(N, q);\u000A  q.copy(host_array, device_data, N).wait();\u000A  return device_data;\u000A}\u000A\u000A}  // namespace fpga_tools\u000A\u000A#endif /* __MEMORY_UTILS_HPP__ */"}, {"path":"/home/u119070/git/elastic-sycl-hls/include_sycl/metaprogramming_utils.hpp", "name":"metaprogramming_utils.hpp", "has_active_debug_locs":false, "absName":"/home/u119070/git/elastic-sycl-hls/include_sycl/metaprogramming_utils.hpp", "content":"#ifndef __METAPROGRAMMING_UTILS_HPP__\u000A#define __METAPROGRAMMING_UTILS_HPP__\u000A\u000A#include <type_traits>\u000A#include <utility>\u000A\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000Anamespace fpga_tools {\u000A\u000A//\u000A// The code below creates the constexprs 'make_integer_range'\u000A// and 'make_index_range' these are akin to 'std::make_integer_sequence'\u000A// and 'std::make_index_sequence', respectively.\u000A// However they allow you to specificy a range and can either increment\u000A// or decrement, rather than a strict increasing sequence\u000A//\u000Atemplate <typename T, typename, T begin, bool increase>\u000Astruct integer_range_impl;\u000A\u000A// incrementing case\u000Atemplate <typename T, T... N, T begin>\u000Astruct integer_range_impl<T, std::integer_sequence<T, N...>, begin, true> {\u000A  using type = std::integer_sequence<T, N + begin...>;\u000A};\u000A\u000A// decrementing case\u000Atemplate <typename T, T... N, T begin>\u000Astruct integer_range_impl<T, std::integer_sequence<T, N...>, begin, false> {\u000A  using type = std::integer_sequence<T, begin - N...>;\u000A};\u000A\u000A// integer_range\u000Atemplate <typename T, T begin, T end>\u000Ausing integer_range = typename integer_range_impl<\u000A    T, std::make_integer_sequence<T, (begin < end) ? end - begin : begin - end>,\u000A    begin, (begin < end)>::type;\u000A\u000A//\u000A// make_integer_range\u000A//\u000A// USAGE:\u000A//    make_integer_range<int,1,10>{} ==> 1,2,...,9\u000A//    make_integer_range<int,10,1>{} ==> 10,9,...,2\u000A//\u000Atemplate <class T, T begin, T end>\u000Ausing make_integer_range = integer_range<T, begin, end>;\u000A\u000A//\u000A// make_index_range\u000A//\u000A// USAGE:\u000A//    make_index_range<1,10>{} ==> 1,2,...,9\u000A//    make_index_range<10,1>{} ==> 10,9,...,2\u000A//\u000Atemplate <std::size_t begin, std::size_t end>\u000Ausing make_index_range = integer_range<std::size_t, begin, end>;\u000A\u000A//\u000A// The code below creates the constexprs 'make_integer_pow2_sequence'\u000A// and 'make_index_pow2_sequence'. These generate the sequence\u000A// 2^0, 2^1, 2^2, ... , 2^(N-1) = 1,2,4,...,2^(N-1)\u000A//\u000Atemplate <typename T, typename>\u000Astruct integer_pow2_sequence_impl;\u000A\u000Atemplate <typename T, T... Pows>\u000Astruct integer_pow2_sequence_impl<T, std::integer_sequence<T, Pows...>> {\u000A  using type = std::integer_sequence<T, (T(1) << Pows)...>;\u000A};\u000A\u000A// integer_pow2_sequence\u000Atemplate <typename T, T N>\u000Ausing integer_pow2_sequence =\u000A    typename integer_pow2_sequence_impl<T,\u000A                                        std::make_integer_sequence<T, N>>::type;\u000A\u000A//\u000A// make_integer_pow2_sequence\u000A//\u000A// USAGE:\u000A//    make_integer_pow2_sequence<int,5>{} ==> 1,2,4,8,16\u000A//\u000Atemplate <class T, T N>\u000Ausing make_integer_pow2_sequence = integer_pow2_sequence<T, N>;\u000A\u000A//\u000A// make_index_pow2_sequence\u000A//\u000A// USAGE:\u000A//    make_index_pow2_sequence<5>{} ==> 1,2,4,8,16\u000A//\u000Atemplate <std::size_t N>\u000Ausing make_index_pow2_sequence = integer_pow2_sequence<std::size_t, N>;\u000A\u000A//\u000A// Checks for existence of subscript operator\u000A//\u000Anamespace detail {\u000Atemplate <typename... >\u000Ausing void_t = void;\u000A\u000Atemplate<class T, typename = void>\u000Astruct has_subscript_impl : std::false_type { };\u000A\u000Atemplate<typename T>\u000Astruct has_subscript_impl<T, void_t<decltype(std::declval<T>()[1])>> \u000A  : std::true_type { };\u000A}  // namespace detail\u000A\u000Atemplate <typename T>\u000Astruct has_subscript {\u000A  static constexpr bool value =\u000A    std::is_same_v<typename detail::has_subscript_impl<T>::type, std::true_type>;\u000A};\u000A\u000Atemplate <typename T>\u000Ainline constexpr bool has_subscript_v = has_subscript<T>::value;\u000A\u000A//\u000A// checks if a type is any instance of SYCL pipe\u000A//\u000Anamespace detail {\u000A\u000Atemplate<typename T>\u000Astruct is_sycl_pipe_impl : std::false_type {};\u000A\u000Atemplate<typename Id, typename T, std::size_t N>\u000Astruct is_sycl_pipe_impl<sycl::ext::intel::pipe<Id, T, N>> : std::true_type {};\u000A\u000A}  // namespace detail\u000A\u000Atemplate <typename T>\u000Astruct is_sycl_pipe {\u000A  static constexpr bool value = detail::is_sycl_pipe_impl<T>{};\u000A};\u000A\u000Atemplate <typename T>\u000Ainline constexpr bool is_sycl_pipe_v = is_sycl_pipe<T>::value;\u000A\u000A} // namespace fpga_tools\u000A\u000A#endif  /* __METAPROGRAMMING_UTILS_HPP__ */"}]